using UnityEngine;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using AStar;

namespace ST
{
    // TODO: needs to be updated for use with new Map data model, pulled from previous project which used gameObjects heavily. 
    // In this case entities probably will be gameObjects, but if you have an RTS or game with massive armies, for example, it may
    // be beneficial to store groups of entities as single mesh, using similar chunking ideas??

    /// <summary>
    /// Entity. Currently supports waypoint movement, generated by an A* implementation. 
    /// Can also use AStarPathfinder from Asset Store, see unity-astarpathfinder-example.
    /// 
    /// TODO: 
    /// - fix movement to adhere to specific map type by calling tile/position methods on map
    /// - might want to refactor to use the new Tileset instead of gameobject
    /// - add path smoothing after receiving set of waypoints from A*
    /// - test navmash navigation with steering behaviors snapping to 4-dir vectors
    /// 
    /// MonoBehavior
    /// - do we need this to derive from MonoBehavior
    /// - if not can we have its gameObject be the link into the Unity component system
    /// - if we use RequireComponent we'll want each component to be MonoBehavior.
    /// - might be necessary "evil" (possibly not even evil) to require most class support the MonoBehavior functionality 
    /// </summary>
    /// 

//    // Require components that are necessary for all entities
//    // - any component like AIComponent can be checked for null instead if desired
//    [RequireComponent(typeof(HealthComponentScript))]
//    [RequireComponent(typeof(MoveComponentScript))]
//    [RequireComponent(typeof(AIComponentScript))]
//    [RequireComponent(typeof(Animator))]
    public class Entity : MonoBehaviour
    {
        public enum EntityState
        {
            Spawning,
            Alive,
            Invincible,
            Dying,
            Dead
        }

        // public for A* unity plugin
        public TileCoord curTile;

        // dependencies
        private Map map;

        // state
        private EntityState entityState;

        // rendering
        private Tileset tileset;
        private Rect currentFrame; // for use with tilesets
        private GameObject gameObject;
        private Animator anim;
        private string animPrefix = "[entity_type_name]";
        private float feetOffset = 0f;
        private float zOffset = -0.75f;

        // movement
        // TODO: move into MoveComponent
        private Vector2 basePos;
        private List<TileCoord> waypoints;
        private TileCoord curWaypoint;
        private TileCoord goalTile;
        private Direction curDir;
        private float speed = 0f;
        private float speedMax = 0f;

        // Entity Components
        private AIComponent cachedAIComponent;
        private InputComponent cachedInputComponent; // direct player character input
        private JobsComponent cachedJobsComponent;
        private StatsComponent cachedStatsComponent;
        //TODO: remove this if not smart, may use List<Units> or UnitManager instead
        //private UnitsComponent cachedUnitsComponent; // entity is a collection of units, or entity controls units

        // Unity Components
        private Animator cachedAnimator;
        private Transform cachedTransform;
        private Rigidbody2D cachedRigidBody2D;

        // Allow for different behavior for different entity
        private Func<bool> onDead;
        private Func<bool> onAction;
        private Func<bool> onPlaySound; 

        // ---------------------------------------------------------------            

        // Should be in highest level class, say Game.cs, where each game's "global" data is stored, don't use singletons if can be helped 
        private static int curGuid = 0;
        private int guid;

        int nextGuid ()
        {
            return curGuid++;
        }

        int getGuid ()
        {
            return this.guid;
        }


        // ---------------------------------------------------------------

        public Entity (Map m)
        {
            this.guid = nextGuid ();
            this.animPrefix = "entity";
            this.map = m;
            this.curTile = null;
            this.curWaypoint = null;
            this.goalTile = null;
            this.waypoints = new List<TileCoord> ();

            this.feetOffset = 28.0f * this.map.tUnit;
            this.speedMax = 60.0f * this.map.tUnit;
        }

        public void EntityStart (GameObject go)
        {
            this.gameObject = go;
            setTile (new TileCoord (5, 10));
            anim = go.GetComponent<Animator> ();
        }

        // TODO: should allow for different death actions
        public void onDeath ()
        {
            this.entityState = EntityState.Dying;

            if (this.onDead != null) {
                this.onDead ();
            }
        }

        // TODO: reimplement with new Map and Tile classes
        public void setPosition (Vector3 p)
        {
            basePos = new Vector2 (p.x, p.y);
            var z = map.TileScreenDepth (new TileCoord (curTile.c, curTile.r, 0)) + zOffset;
            var h = map.TileYOffsetForHeight (curTile);

            //Debug.Log ("p = " + p + ", h = " + h + ", z = " + z + ", feetOffset = " + feetOffset + " =>  @ " + curTile);

            Vector3 pos = new Vector3 (p.x, p.y + h + feetOffset, z);
            gameObject.transform.position = pos;
        }

        public void updateFlip ()
        {
            // TODO: only change if different
            Vector3 scale = gameObject.transform.localScale;
            
            // TODO: cache 
            bool flip = scale.x <= 0 && (curDir == Direction.NorthEast || curDir == Direction.SouthEast);
            flip = flip || (scale.x >= 0 && (curDir == Direction.NorthWest || curDir == Direction.SouthWest));
            if (flip) {
                scale.x *= -1;
            }
            gameObject.transform.localScale = scale;

            // TODO: rotate instead of scale, check references to see which is better
            // TODO: check if need radians? /Mathf.PI);
            // or rotate rotate.y = 180deg
            //gameObject.transform.RotateAround(new Vector3(0, 0, 0), Vector3.up, 180); 
        }

        // TODO: need to change to pull sequence of images/textures/tiles, or write about creating Animators in Unity's editor
        public void updateAnim ()
        {
            // NOTE: can't wait for dir change as current code is written or never move into idle
//          if (oldDir != curDir) {
            string animName = null;

            switch (curDir) {
            case Direction.NorthEast:
            case Direction.NorthWest:
                if (speed > 0)
                    animName = "walk-ne";
                else
                    animName = "idle-ne";
                break;
            case Direction.SouthEast:
            case Direction.SouthWest:
                if (speed > 0)
                    animName = "walk-se";
                else
                    animName = "idle-se";
                break;
            }

            if (null != anim && null != animName) {
                // TODO: create animator from scratch, or define required naming scheme "entity_name-anim_name"
                string animHashString = this.animPrefix + "-" + animName;
                int animHash = Animator.StringToHash (animHashString);
                anim.CrossFade (animHash, 0.1f);
                anim.Play (animHash);
            }
//          }
        }

        public void EntityUpdate ()
        {
            Vector2 curPos = basePos;

            if (null != curWaypoint || null != goalTile) {
                Debug.Log ("trying to get next waypoint " + UnityEngine.Time.time);
                TileCoord nextTile = curWaypoint != null ? curWaypoint : goalTile != null ? goalTile : null;
                if (null != nextTile) {
                    Vector3 pos3 = map.worldFromTile (nextTile);                   
                    Vector2 pos = new Vector2 (pos3.x, pos3.y);

                    var delta = pos - curPos;

                    // TODO: should change direction only when getting next tile
                    // direction based on position change 
                    if (delta.y > 0) {
                        curDir = delta.x < 0 ? Direction.NorthWest : Direction.NorthEast;
                    } else {   
                        curDir = delta.x < 0 ? Direction.SouthWest : Direction.SouthEast;
                    }

                    speed = speedMax;
                    var vel = delta.normalized * speed * UnityEngine.Time.deltaTime;
                    vel = new Vector2 (vel.x, vel.y);
                    Debug.Log ("velocity = " + vel);
                    curPos += vel;

                    var epsilon = 1E-04f;
                    var dist = Vector3.Distance (curPos, pos);

                    if (dist < epsilon || dist <= 2.5f * vel.magnitude) {
                        //map.changeTileIndex (nextTile, 1);
                        //TODO: map.changeTileColor (nextTile, new Color (1f, 1f, 1f));
                        //TODO: curPos = map.posForTile (nextTile);
                        curTile = nextTile;

                        if (null != curWaypoint) {
                            Debug.Log ("finished waypoint");
                            if (waypoints.Count () > 0) {
                                curWaypoint = waypoints [0];
                                waypoints.RemoveAt (0);
                            } else {
                                curWaypoint = null;
                            }
                        } else {
                            Debug.Log ("finished goal");
                            goalTile = null;
                        }
                    } else {
                        // check if we've moved to a new tile
                        var coord = map.tileFromWorld (curPos);
                        if (curTile == null || coord.c != curTile.c || coord.r != curTile.r) {
                            if (map.TileIsCollision (coord)) {
                                // reset (move back)
                                curPos = basePos;
                                resetWaypoints ();
                            } else {
                                curTile = coord;
                            }
                        }
                    }
                }
            } else {
                speed = 0.0f;
            }

            setPosition (new Vector3 (curPos.x, curPos.y));

            updateFlip ();
            updateAnim ();

        }

        public void resetWaypoints ()
        {
            // TODO: fix map to allow
            if (null != curWaypoint)
                map.SetTileColor (curWaypoint, new Color (1f, 1f, 1f));
            if (null != goalTile)
                map.SetTileColor (goalTile, new Color (1f, 1f, 1f));
            
            curWaypoint = null;
            goalTile = null;
            waypoints.Clear ();
        }

        // Simple Astar pathfinding
        public void setGoalTileSimpleAStar (TileCoord coord)
        {
            string startCity = "tile_" + curTile.r + "_" + curTile.c;
            string destinationCity = "tile_" + goalTile.r + "_" + goalTile.c;
        
            AStar.Node start = null; // TODO: map.graph.Nodes [startCity];
            AStar.Node destination = null; // TODO: map.graph.Nodes [destinationCity];

            // TODO: move this outside this method or cache it
            // Function which tells us the exact distance between two neighbours.
            Func<AStar.Node, AStar.Node, double> distanceFunc = (node1, node2) => {
                AdjacencyList neighbors = node1.Neighbors;
                var etns = neighbors.Cast<AStar.EdgeToNeighbor> ();
                var edge = etns.Single (etn => etn.Neighbor.Key == node2.Key);
                double cost = edge.Cost;
                return cost;
            };
            
            // Estimation/Heuristic function (Manhattan distance)
            // It tells us the estimated distance between the last node on a proposed path and the destination node.
            Func<AStar.Node, double> manhattanEstimation = n => Math.Abs (n.X - destination.X) + Math.Abs (n.Y - destination.Y);

            Debug.Log ("starting find path from " + startCity + " to " + destinationCity);
            AStar.Path<AStar.Node> shortestPath = FindPath (start, destination, distanceFunc, manhattanEstimation);

            // DEBUG LOG
            // Prints the shortest path.
            if (shortestPath != null && shortestPath.Count () > 0) {
                Debug.Log ("\nThis is the shortest path based on the A* Search Algorithm:\n");
                foreach (AStar.Path<AStar.Node> path in shortestPath.Reverse()) {
//              if (path.PreviousSteps != null) {
//                  Debug.Log (string.Format ("From {0, -15}  to  {1, -15} -> Total cost = {2:#.###}",
//                                                  path.PreviousSteps.LastStep.Key, path.LastStep.Key, path.TotalCost));
//              }

                    int c = path.LastStep.X;
                    int r = path.LastStep.Y;

                    Debug.Log ("adding waypoint " + r + ", " + c);
                    waypoints.Add (new TileCoord (c, r, -1));
                }
            }
        }

        // Cheap "seek" pathfinding
        public void setGoalTileSeek (TileCoord coord)
        {
            int dc = goalTile.c - curTile.c;
            int dr = goalTile.r - curTile.r;

            curDir = Direction.None;
            if (Mathf.Abs (dc) > Mathf.Abs (dr)) {
                // move along c-axis
                curDir = dc < 0 ? Direction.NorthWest : Direction.SouthEast;
                waypoints.Add (new TileCoord (goalTile.c, curTile.r, -1));
            } else {   
                // move along r-axis
                curDir = dr < 0 ? Direction.SouthWest : Direction.NorthEast;
                waypoints.Add (new TileCoord (curTile.c, goalTile.r, -1));
            }
            Debug.Log ("dc = " + dc + ", dr = " + dr + ", # waypoint = " + waypoints.Count ());
        }

        public void setGoalTile (TileCoord coord)
        {
            // TODO: fix map to allow
            if (! this.map.IsTileValid (coord)) {
                return;
            }

            waypoints.Clear ();

            var pos = basePos;
            curTile = map.tileFromWorld (pos);
            goalTile = coord;

            if (map.UseAstarPathfinding) {
                if (map.UseSimple2Dastar) {
                    setGoalTileSimpleAStar (coord);
                } else {
                    // use the actual A* plugin                  
                }
            } else {
                setGoalTileSeek (coord);
            }

            if (waypoints.Count () > 0) {
                curWaypoint = waypoints [0];
                map.SetTileColor (curTile, new Color (1f, 0.3f, 0.3f));
                map.SetTileColor (curWaypoint, new Color (0.3f, 0.3f, 1f));
            }
        }

        public void setTile (TileCoord coord)
        {
            if (tileset == null) {
//                // load tileset
//                Vector2 tilePixelSize = new Vector2 (64, 64);
//                //Vector2 tileAnchorPoint = new Vector2 (0.5f, 0.25f);
//                Vector2 tileBaseSize = new Vector2 (1, 1); // how many map base tiles in size NxM
//
//                this.tileset = new Tileset (map, "terrain_1", tilePixelSize, tileBaseSize);
//                var renderer = this.gameObject.GetComponent<MeshRenderer> (); 
//                var mat = renderer.materials [0];
//                mat.mainTexture = tileset.getTexture ();
//                mat.shader = Shader.Find ("Steve/Mesh");
            }
            curTile = coord;

            var xy = map.worldFromTile (curTile);
            setPosition (new Vector3 (xy.x, xy.y));
        }

        /// <summary>
        /// Custom pathfinder that uses AStar lib to get nodes from start to destination
        /// </summary>
        static public AStar.Path<TNode> FindPath<TNode> (
            TNode start,
            TNode destination,
            Func<TNode, TNode, double> distance,
            Func<TNode, double> estimate) where TNode : AStar.IHasNeighbours<TNode>
        {
            var closed = new HashSet<TNode> ();            
            var queue = new AStar.PriorityQueue<double, Path<TNode>> ();            
            queue.Enqueue (0, new AStar.Path<TNode> (start));
            
            while (!queue.IsEmpty) {
                var path = queue.Dequeue ();
                
                if (closed.Contains (path.LastStep)) {
                    continue;
                }

                if (path.LastStep != null) {
                    if (path.LastStep.Equals (destination)) {
                        return path;
                    }
                
                    closed.Add (path.LastStep);
                
                    foreach (TNode n in path.LastStep.Neighbours) {
                        double d = distance (path.LastStep, n);                    
                        var newPath = path.AddStep (n, d);                    
                        queue.Enqueue (newPath.TotalCost + estimate (n), newPath);
                    }
                }
            }
            
            return null;
        }
    }
}
